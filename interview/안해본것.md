# Distributed Systems Interview Q&A

---

# 📌 A. 대규모 분산 트랜잭션

---

## Q1. MSA 환경에서 트랜잭션 정합성은 어떻게 보장하나요?

### 핵심 개념
- ACID → 단일 DB 환경
- MSA → BASE (Eventually Consistent)
- Strong Consistency vs Eventual Consistency

### 답변 템플릿

MSA 환경에서는 서비스 간 분산 트랜잭션을 ACID로 유지하기 어렵습니다.

따라서 다음 전략을 사용합니다:

1. Saga Pattern 기반 트랜잭션 분리
2. 비동기 이벤트 기반 처리
3. 보상(Compensation) 트랜잭션 설계
4. 최종 정합성 재검증 단계 도입

강한 일관성을 유지하기보다는,
Eventually Consistency를 수용하고
실패 시 보상 로직으로 복구하는 구조를 설계합니다.

---

## Q2. 2PC(2 Phase Commit)는 어떻게 생각하나요?

### 장점
- 강한 일관성 보장

### 단점
- Coordinator 장애 시 블로킹
- Latency 증가
- 확장성 저하
- 네트워크 비용 증가

### 답변 템플릿

2PC는 강한 일관성을 보장하지만,
대규모 분산 환경에서는 가용성과 확장성을 희생하게 됩니다.

따라서 대부분의 MSA 환경에서는
Saga 기반 보상 트랜잭션이 더 현실적인 선택이라고 생각합니다.

---

## Q3. Saga 패턴 설명해보세요.

### Saga 종류

1. Choreography (이벤트 기반)
2. Orchestration (중앙 제어 기반)

| 구분 | Choreography | Orchestration |
|------|--------------|---------------|
| 제어 방식 | 분산 이벤트 | 중앙 Orchestrator |
| 장점 | 느슨한 결합 | 흐름 가시성 |
| 단점 | 추적 어려움 | SPOF 위험 |

### 답변 템플릿

Saga는 트랜잭션을 여러 단계로 나누고,
각 단계 실패 시 보상 트랜잭션을 수행하는 방식입니다.

도메인 복잡도에 따라
Choreography 또는 Orchestration을 선택합니다.

---

## Q4. 이벤트 기반 구조에서 데이터 일관성은 어떻게 유지하나요?

### 전략
- Idempotent 처리
- Retry 메커니즘
- Dead Letter Queue
- 재검증 단계 도입

### 답변 템플릿

이벤트 기반 구조에서는
Exactly-once를 강제하기보다
At-least-once + Idempotency 전략을 사용합니다.

또한,
최종 사용자 노출 직전
정합성 재검증 단계를 두는 것이 중요합니다.

---

# 📌 B. 캐시 설계

---

## Q5. 캐시 전략은 어떻게 설계하나요?

### 기본 전략
- Cache Aside
- TTL 설정
- Hot key 분산
- 무효화 전략 설계

### 답변 템플릿

저는 기본적으로 Cache Aside 전략을 사용합니다.
DB를 Source of Truth로 두고,
읽기 부하를 줄이기 위해 캐시를 활용합니다.

TTL과 무효화 전략을 함께 설계하는 것이 핵심입니다.

---

## Q6. Cache Aside vs Write Through 차이?

### Cache Aside
- 조회 시 Cache Miss → DB 조회 후 캐시 저장
- 구현 단순
- 읽기 위주 서비스 적합

### Write Through
- DB 저장 시 Cache도 함께 저장
- 일관성 높음
- 쓰기 비용 증가

### 답변 템플릿

읽기 중심 서비스라면 Cache Aside,
일관성이 중요한 서비스라면 Write Through가 적합합니다.

---

## Q7. 캐시 무효화 전략은?

### 전략
- TTL 기반 만료
- Write 시 삭제
- Version 기반 키 관리
- Event 기반 무효화

### 답변 템플릿

캐시 무효화는 가장 어려운 문제입니다.

저는:
- TTL 랜덤화
- Write 시 캐시 삭제
- 이벤트 기반 무효화
를 조합해 설계합니다.

---

## Q8. Redis 장애 시 어떻게 대응?

### 전략
- Circuit Breaker
- Fallback to DB
- Rate Limiting
- Cache Warm-up

### 답변 템플릿

Redis 장애 시 DB fallback 구조를 준비합니다.
단, DB 과부하 방지를 위해
Rate limiting과 Circuit breaker를 함께 사용합니다.

---

# 📌 C. 메시지 브로커

---

## Q9. Kafka 사용해봤나요?

### 답변 전략

직접 Kafka를 깊게 운영하지 않았다면:

Kafka 기반 Consumer 구조를 사용해본 경험은 있으며,
At-least-once 기반 동기화 모델을 이해하고 있습니다.

---

## Q10. at-least-once vs exactly-once 차이?

| 전략 | 특징 |
|------|------|
| At-least-once | 중복 가능 |
| At-most-once | 유실 가능 |
| Exactly-once | 중복/유실 없음 (비용 큼) |

### 답변 템플릿

대부분의 시스템에서는
At-least-once + Idempotent 설계를 사용합니다.
Exactly-once는 비용과 복잡성이 높습니다.

---

## Q11. 메시지 중복 처리 어떻게 하나요?

### 전략
- Unique Key 기반 검증
- 상태 기반 처리
- Deduplication Store
- Idempotent API 설계

### 답변 템플릿

중복은 허용하되,
멱등성을 보장하는 설계를 합니다.

---

## Q12. Consumer Lag 발생 시 대응 방법은?

### 전략
- Consumer 수 확장
- Partition 재조정
- 처리 로직 최적화
- Backpressure 조절

### 답변 템플릿

Lag는 처리량 부족 신호입니다.
수평 확장 또는 병목 분석을 통해 해결합니다.

---

# 📌 D. DB 샤딩 / 멀티리전

---

## Q13. 샤딩 전략 설명해보세요.

### 전략 종류
- Range Sharding
- Hash Sharding
- Consistent Hashing

샤딩은 데이터 분산을 통한 확장 전략입니다.

---

## Q14. Range Sharding vs Hash Sharding 차이?

| 구분 | Range | Hash |
|------|-------|------|
| 장점 | 범위 조회 용이 | 균등 분산 |
| 단점 | Hotspot 발생 | 재샤딩 비용 |

### 답변 템플릿

트래픽 분포에 따라 전략을 선택합니다.
균등 분산이 중요하면 Hash,
범위 조회가 중요하면 Range가 적합합니다.

---

## Q15. 멀티리전 환경에서 데이터 일관성 어떻게 유지?

### 전략
- Active-Passive
- Active-Active
- Eventual Consistency 수용
- Global Load Balancer 활용

### 답변 템플릿

멀티리전에서는 Strong Consistency보다
가용성과 지연 시간 균형이 중요합니다.

데이터 특성에 따라 일관성 수준을 조정합니다.

---

## Q16. Read Replica 활용 전략?

### 전략
- Write: Primary
- Read: Replica
- 읽기 부하 분산
- Replica Lag 고려

### 답변 템플릿

읽기 위주 서비스에서
Replica를 활용해 확장합니다.
단, Replica Lag에 따른 정합성 문제를 고려해야 합니다.




# Distributed Transaction Deep Dive

---

## Q1. MSA 환경에서 트랜잭션 정합성은 어떻게 보장하나요?

### 핵심 개념

- ACID → 단일 DB 트랜잭션
- MSA → BASE (Eventually Consistent)
- Strong Consistency vs Eventual Consistency

### 면접 답변 구조

MSA 환경에서는 전통적인 ACID 트랜잭션을 서비스 간에 유지하기 어렵습니다.

대신 다음 전략을 사용합니다:

1. Saga Pattern 적용
2. 비동기 이벤트 기반 처리
3. 보상 트랜잭션 설계
4. 최종 재검증 단계 도입

강한 정합성 대신  
Eventually Consistency를 수용하고  
실패 시 보상 로직으로 복구합니다.

---

## Q2. 2PC는 왜 잘 사용하지 않나요?

### 2PC 문제점

- Coordinator 장애 시 블로킹
- Latency 증가
- 확장성 저하
- 네트워크 비용 증가

### 답변 예시

2PC는 강한 일관성을 보장하지만,
대규모 분산 시스템에서는 확장성과 가용성을 희생합니다.

대신 Saga 기반 보상 트랜잭션이 더 현실적인 선택입니다.

---

## Q3. Saga 패턴 설명해주세요.

### Saga 종류

1. Choreography (이벤트 기반)
2. Orchestration (중앙 제어 기반)

### 비교

| 항목 | Choreography | Orchestration |
|------|--------------|---------------|
| 구조 | 느슨한 결합 | 중앙 집중 |
| 장점 | 확장성 높음 | 흐름 명확 |
| 단점 | 흐름 추적 어려움 | SPOF 위험 |

### 면접 답변

트랜잭션을 작은 단위로 분리하고,
각 단계 실패 시 보상 트랜잭션을 수행합니다.

중앙 Orchestrator를 둘지,
이벤트 기반으로 처리할지는
도메인 복잡도에 따라 결정합니다.




# Cache Strategy Deep Dive

---

## Q1. Cache Aside vs Write Through 차이?

### Cache Aside (Lazy Loading)

Flow:
1. Cache 조회
2. Miss → DB 조회
3. Cache 저장

장점:
- 구현 간단
- DB 정합성 유지 쉬움

단점:
- Cache Miss 시 지연 발생

---

### Write Through

Flow:
1. DB 저장
2. Cache 동시 저장

장점:
- 읽기 일관성 높음
- Cache Hit율 높음

단점:
- 쓰기 지연 증가

---

## Q2. Cache Stampede 방지 전략은?

- TTL 랜덤화
- Mutex Lock
- Request Coalescing
- Background Refresh

---

## Q3. Redis 장애 시 대응?

1. Cache fallback
2. Circuit Breaker
3. Rate limiting
4. Cache Warm-up 전략

---

## 면접 답변 템플릿

캐시는 DB 부하를 줄이기 위한 전략이지만,
정합성과 무효화 전략이 핵심입니다.

저는:
- Cache Aside 기본 전략
- TTL 랜덤화
- Hot key 분산
을 기본 설계 원칙으로 둡니다.



# Kafka / Message Broker Deep Dive

---

## Q1. At-least-once vs Exactly-once 차이?

| 전략 | 특징 |
|------|------|
| At-least-once | 중복 가능 |
| At-most-once | 유실 가능 |
| Exactly-once | 중복/유실 없음 (복잡) |

---

## Q2. 중복 메시지 처리 방법은?

- Idempotent 처리
- Unique Key 검증
- 상태 기반 중복 체크
- Deduplication Store

---

## Q3. Consumer Lag 발생 시 대응?

1. Consumer 수 증가
2. Partition 재분배
3. 처리 로직 최적화
4. Backpressure 조정

---

## Q4. Partition 전략은?

- Key 기반 분산
- Hash 기반 분산
- Hot key 방지 필요

---

## 면접 답변 템플릿

메시지 시스템에서 가장 중요한 것은
"중복은 허용하되, 멱등성을 보장하는 것"이라고 생각합니다.

Exactly-once는 비용이 크기 때문에
대부분 At-least-once + Idempotency로 해결합니다.



# Sharding & Multi-Region Design

---

## Q1. Sharding 전략 설명

### 1. Range Sharding
- ID 범위 기반 분리
- Hotspot 위험

### 2. Hash Sharding
- 해시 기반 분산
- 균등 분산 가능
- 재샤딩 비용 발생

### 3. Consistent Hashing
- 노드 추가 시 영향 최소화

---

## Q2. Hotspot 문제는?

- 특정 Key에 트래픽 집중
- 해결:
  - 랜덤 키 추가
  - 분산 Key 전략
  - Read Replica 분산

---

## Q3. Read Replica 전략

- Primary: Write
- Replica: Read
- 읽기 부하 분산
- Replica Lag 고려 필요

---

## Q4. Multi-Region 설계

### 전략

- Active-Passive
- Active-Active
- Global Load Balancer
- Data Replication

### Trade-off

- Strong Consistency ↓
- Latency ↑
- 운영 복잡도 ↑

---

## 면접 답변 템플릿

멀티리전에서는 강한 일관성보다
가용성과 지연 시간의 균형이 중요합니다.

데이터 특성에 따라:
- 강한 정합성 필요 → 단일 리전
- 읽기 위주 서비스 → 리전 복제

전략을 다르게 가져가야 합니다.
