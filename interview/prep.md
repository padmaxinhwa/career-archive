# Interview Q&A – Architecture & System Design Focus

---

## 🧩 MSA 관련

### Q1. 왜 MSA로 전환했나요?

**A.**

레거시 구조에서는 다음과 같은 문제가 있었습니다:

- Mongo 직접 조회 기반 로직으로 서비스 간 결합도 증가
- 중복 데이터 타입 존재
- 확장 시 코드 변경 범위 과다

MSA 전환을 통해:

- 인덱스 책임을 분리하고
- 배치 + Consumer 기반 동기화 구조로 변경
- 서비스 단위 확장성을 확보했습니다.

단순히 "MSA가 트렌드라서"가 아니라,  
**확장성과 책임 분리를 위해 구조적으로 필요했기 때문입니다.**

---

### Q2. MSA 전환하면서 가장 어려웠던 점은?

**A.**

가장 어려웠던 부분은 정합성 관리였습니다.

레거시에서는 하나의 트랜잭션 안에서 처리되던 로직이  
MSA에서는 비동기 이벤트 기반으로 분리되었기 때문에  
동기화 타이밍과 데이터 정합성 보장이 핵심 이슈였습니다.

이를 해결하기 위해:

- Consumer 기반 변경 반영 구조 설계
- 후처리 검증 로직 추가
- API 체인 기반 재검증 단계 도입

을 통해 정합성을 확보했습니다.

---

### Q3. 배치 + Consumer 구조를 왜 선택했나요?

**A.**

실시간 동기화가 필요하지 않은 영역이었기 때문에  
Event-driven 기반 Consumer 구조가 적합했습니다.

- 대량 데이터는 배치로 처리
- 변경 이벤트는 Consumer로 반영
- 조회는 별도 인덱스 컬렉션에서 수행

이 구조는 조회 성능과 쓰기 확장성을 분리할 수 있다는 장점이 있습니다.

---

## ⚡ WebFlux → Virtual Thread 전환

### Q4. 왜 Reactive(WebFlux)를 버렸나요?

**A.**

Reactive 모델은 높은 동시성을 처리하는 데 장점이 있지만,

- 이벤트 기반 구조의 복잡성 증가
- 디버깅 난이도 상승
- Stack trace 추적 어려움
- 팀 내 유지보수 부담 증가

문제가 발생했습니다.

실제 트래픽 패턴을 분석했을 때  
CPU-bound보다는 IO-bound 작업 비중이 높았고,  
Java 21 Virtual Thread 도입으로 충분히 처리 가능하다고 판단했습니다.

---

### Q5. Virtual Thread의 장점은 무엇인가요?

**A.**

- 블로킹 코드 작성 가능
- 기존 동기 코드 스타일 유지 가능
- 디버깅 및 에러 추적 용이
- 코드 가독성 향상

Reactive 대비 구조가 단순해져  
팀 전체 생산성이 향상되었습니다.

---

### Q6. 언제 Reactive가 더 적합하다고 보나요?

**A.**

- 매우 높은 동시성 처리
- Non-blocking end-to-end 파이프라인 필요
- Backpressure 관리가 중요한 경우

이런 경우에는 Reactive가 더 적합하다고 생각합니다.

---

## 🏗 ArchUnit 관련

### Q7. 왜 ArchUnit을 도입했나요?

**A.**

패키지 간 의존성 규칙이 코드리뷰에만 의존하고 있었기 때문입니다.

아키텍처 규칙은 사람이 기억해야 하는 것이 아니라  
테스트로 강제되어야 한다고 생각했습니다.

---

### Q8. DSL 대신 Core API를 사용한 이유는?

**A.**

- 타겟 클래스 가시성을 명확히 보고 싶었고
- 세밀한 조건 제어가 필요했기 때문입니다.

DSL은 가독성 측면에서 장점이 있지만  
초기에는 Core API가 더 명확한 제어를 가능하게 했습니다.

---

### Q9. ArchUnit 도입 후 어떤 변화가 있었나요?

**A.**

- 구조 위반이 테스트 단계에서 즉시 실패
- 코드리뷰 커뮤니케이션 감소
- 신규 개발 시 레이어 오염 방지

아키텍처 안정성이 크게 향상되었습니다.

---

## 🛠 상품 유효성 검증기

### Q10. 이걸 왜 개발했나요?

**A.**

MSA 전환 이후 재고 동기화 이슈가 증가했고  
운영 문의 대응 시 수기 로그 분석이 필요했습니다.

개발자가 직접 API를 호출하고  
로그를 추적해야 하는 비효율적인 구조였습니다.

---

### Q11. 단순 로그로 해결하면 안 됐나요?

**A.**

로그는 "결과"만 보여줍니다.

하지만 문제는:

- 어느 API 단계에서 데이터가 달라졌는지
- 파라미터가 어떻게 전달되었는지
- 최종 노출 로직이 어떻게 판단했는지

를 종합적으로 확인해야 했습니다.

그래서 API 체인 흐름을 그대로 재현하는 도구를 만들었습니다.

---

### Q12. 실제 효과는 무엇이었나요?

**A.**

- 수기 API 호출 및 로그 분석 프로세스 제거
- 원인 분석 시간 단축
- 운영 대응 속도 개선

운영 리소스를 줄이고  
문제 분석을 시스템화할 수 있었습니다.

---

## 🧠 설계 철학

### Q13. 설계 시 가장 중요하게 보는 기준은?

**A.**

1. 확장 가능성
2. 정합성 보장 구조
3. 복잡도 최소화
4. 팀이 이해 가능한 구조인지

기술 선택은 "멋있음"이 아니라  
팀 전체 생산성에 기여하는가를 기준으로 합니다.

---

### Q14. 코드 복잡도를 어떻게 줄였나요?

**A.**

- 저사용 고비용 기능 제거
- 데이터 타입 통합
- API 체인 구조 표준화
- 동시성 모델 단순화 (Reactive → Virtual Thread)

복잡성은 기능이 아니라 구조에서 발생한다고 생각합니다.

---

## 🎯 한 줄 요약

- 구조 문제를 발견하고
- 기술 선택을 통해 해결하며
- 운영을 시스템화하는 엔지니어입니다.
